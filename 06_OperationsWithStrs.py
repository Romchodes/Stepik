'''
Больше та строка, которая начинается на символ, который имеет большее значение в таблице ASCII символов:
https://ascii.cl/
И получается, что хотя
'A' < 'Z' #True
и
'a' < 'z' #True
но при этом
'a' < 'Z' #False
Это объясняется тем, что все заглавные символы латинского алфавита имеют меньшее значение в таблице ASCII,
нежели все строчные символы латинского алфавита. Так как все заглавные символы идут в этой таблице раньше.

- Если сравниваем обычные числа: 3>2 True,7<9 true,8=8 true
- Если сравниваем строки,то та строка больше, которая начинается на символ,
который имеет большее значение в таблице ASCII символов, пример: 'c'>'bbbb' #True
- Если символы двух строк совпадают,но одна больше на один символ,то больше она
Пример:"cca">"ccam" #False
ЭТО относится ко ВСЕМ символами ("5">"22" #true) потому что каждый символ имеет свой код в таблице ASCII и
сравнение происходит по  именно по этому коду

Если ещё не поняли:

("5">"22" #true)  ->  53  > 50 50

53>50-Верно? Всё значит,дальше Python не проверяет строки,чтобы увидеть какие коды у символов
смотрим сюда -> http://ascii.cl/ (Первый столбец)

Конкатинировать строки просто '+' лучше не надо, так как при каждом сложении создаются дополнительные строки,
которые используют память.
Их будет убирать Garbage Collector, занимая процессорное время.
Лучше использовать str.join или str.format
'''

print('abc'>'abcd') # false - если одна строка равна другой строке, но имеет плюсом еще символы в окончании,
# то больше та, в которой больше символов
print('abc'>'b') # false, так как сравниваем посимвольно, первый символ 'a' и 'b' - тут 'b' больше, дальше не сравниваем
print('abc'>'3') # true, так как символ '3' в таблице ASCII имеет значение 51, а первый символ 'a' (строки 'abc')
# имеет значение 97
string1 = 'abc'
string2 = 'def'
print(''.join([string1, string2]))
''' Сложение 2х строк, перед .join указывается разделитель (в данном случае это
отсутствие символа, но можно указать любой), который вставляется между строками.
Сами строки указываются как массив (turple?).
Если указать str.join(string1, string2), то ответ будет 'dabceabcf',
то есть string1 воспринимается как разделитель и вставляется между каждым элементом string2'''

'''Дальше интересный пример, нашел в инете
https://towardsdatascience.com/do-not-use-to-join-strings-in-python-f89908307273'''

strs = ['Life', 'is', 'short,', 'I', 'use', 'Python']
def join_strs(strs): # создаем функцию
    global result # объявляем переменную result глобальной, (?) чтобы она была доступна вне функции
    result = '' # присваиваем пустое значение локальной переменной
    for s in strs: # цикл
        result += ' ' + s # прибавляем к каждому элементу result пробел спереди и еще элемент strs
    return print(result[1:]) # выводим result, начиная с первого элемента result[1], так как нулевой элемент result[0] равен ' '
join_strs(strs)
print(result) # тут выведется строка полностью с нулевым элементом, равным ' '